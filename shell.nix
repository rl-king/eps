{ pkgs ? import
    # pin the nix package set (stable 18.09 at 1 Nov 2018)
    ( let rev = "06fb0253afabb8cc7dc85db742e2de94a4d68ca0";
      in builtins.fetchTarball
          {
            name = "nixpkgs-${rev}";
            url = "https://github.com/NixOS/nixpkgs-channels/archive/${rev}.tar.gz";
            # hash generated by doing `nix-prefetch-url --unpack https://github.com/NixOS/nixpkgs-channels/archive/${rev}.tar.gz`
            sha256 = "0jkldgvdm8pl9cfw5faw90n0qbbzrdssgwgbihk1by4xq66khf1b";
          }
    )
    # customize the package set
    { overlays = [
        (self: super:
          { elmPackages = super.elmPackages // {
              # add latest beta elm test which is missing
              elm-test = self.callPackage ./nix/elm-test {nodejs = self.nodejs-8_x;};
            };
            # needed by elm-test
            binwrap = self.callPackage ./nix/binwrap {nodejs = self.nodejs-8_x;};
          }
        )
      ];
    }
, compiler ? pkgs.haskell.packages.ghc843
}:
let # regenerate by calling `stack2nix ./ > nix/stackPackages.nix`
    stackPackages = import ./nix/stackPackages.nix {inherit pkgs compiler;};

    # a GHC with all the dependent libraries installed and registered
    ghc = pkgs.haskellPackages.ghcWithHoogle
      ( hs: (pkgs.haskell.lib.getHaskellBuildInputs stackPackages.eps)
      );

    # stack available in the shell is setup so that
    #   it uses the GHC along and Haskell libraries supplied by the shell.
    #   it forces nix integration on.
    #   it forces the use of an impure nix sub environment since since the current, possibly pure, nix environment is used.
    stackWrapped = pkgs.runCommand "stack-wrapped" {
      buildInputs = [pkgs.makeWrapper];
    }
    ''
      mkdir -p $out/bin
      makeWrapper \
        ${pkgs.stack}/bin/stack \
        $out/bin/stack \
        --add-flags "--system-ghc" \
        --add-flags "--no-install-ghc" \
        --add-flags "--nix" \
        --add-flags "--no-nix-pure" \
    '';

    # all the dependencies that we are making use of in the shell
    dependencies = with pkgs;
      lib.concatMap
        (dep: if dep ? outputs
              then builtins.map (o: dep."${o}")
              dep.outputs else [dep]
        )
        [ # development build dependencies
          ghc stackWrapped elmPackages.elm elmPackages.elm-format elmPackages.elm-test
          # utilities for generating stackage packages from stack.yaml
          stack2nix nix-prefetch-scripts
          # pure build environment and keep it alive
          nix nix.dev stdenv bashInteractive glibcLocales stdenvNoLibs stdenvNoCC
          # two different store locations to relay on to avoid collection of package set
          pkgs.path (builtins.toString pkgs.path)
        ];

    # fake package explicitly adding dependencies to all the shell dependencies for adding GC roots
    pathToDependencies = pkgs.runCommand "build" {
      name = "${stackPackages.eps.pname}-pathToDependencies";
      paths = dependencies;
    } "echo $paths > $out";

   # create the non buildable shell only environment
in pkgs.mkShell {

  name = "${stackPackages.eps.pname}-shell";

  buildInputs = dependencies;

  # needed for `nix-shell --pure --run "stack build"` to work
  # also why nix it self is a dependency
  NIX_PATH = "nixpkgs=${pkgs.path}";

  # perform some setup on entering the shell
  shellHook = ''

    # add GC roots so that nix-collect-garbage does not delete our environment
    mkdir -p ./.gcroots
    # GC root to the actual shell file
    ${pkgs.nix}/bin/nix-instantiate ./shell.nix --indirect --add-root "./.gcroots/$(basename $out)-shell.drv"
    # GC root to the fake package which keeps all our dependencies alive
    ${pkgs.nix}/bin/nix-store --add-root ./.gcroots/$(basename ${pathToDependencies}) --indirect --realise ${pathToDependencies};

    # expose the supplied GHC and haskell libraries
    eval $(egrep ^export ${ghc}/bin/ghc)
  '';
}
